//  LIB.rs
//    by Lut99
//
//  Created:
//    18 Mar 2024, 13:25:32
//  Last edited:
//    19 Mar 2024, 10:34:49
//  Auto updated?
//    Yes
//
//  Description:
//!   Implements the `datalog!{}`-macro for the `justact-datalog`-crate.
//

use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::quote_spanned;
use syn::parse::{Error, Parse, ParseStream, Parser};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned as _;
use syn::token::{Colon, Comma, Dot, Minus, Paren, PathSep};
use syn::{parenthesized, Attribute, Expr, ExprLit, Ident, Lit, LitStr, Meta, Path, PathArguments, PathSegment, Token};


/***** HELPER FUNCTIONS *****/
/// Parses a comma-separated list as long as it's nice.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
/// - `what`: Another parser that represents the values in the list.
///
/// # Returns
/// A [`Punctuated`] that contains the parsed elements.
///
/// # Errors
/// This function errors if we failed to parse at all.
fn parse_punctuated<T>(input: ParseStream, what: fn(input: ParseStream) -> Result<T, Error>) -> Result<Punctuated<T, Comma>, Error> {
    // See if we can parse a value
    let mut res: Punctuated<T, Comma> = Punctuated::new();
    while let Ok(val) = what(input) {
        res.push_value(val);

        // Attempt to parse an punctuation
        if let Ok(punct) = input.parse::<Comma>() {
            res.push_punct(punct);
        }
    }
    Ok(res)
}

/// Parses a consequent.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
///
/// # Returns
/// A parsed consequent, as a tuple of an identifier and an optional argument list wrapped in parenthesis.
fn parse_consequent(input: ParseStream) -> Result<(Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Error> {
    // Parse the first identifier
    let name: Ident = input.parse()?;

    // Parse the parenthesis optionally
    let args: Option<(Paren, Punctuated<Ident, Comma>)> = |input: ParseStream| -> Result<(Paren, Punctuated<Ident, Comma>), Error> {
        let content;
        let paren: Paren = parenthesized!(content in input);
        let args: Punctuated<Ident, Comma> = content.parse_terminated(Ident::parse, Token![,])?;
        Ok((paren, args))
    }(input)
    .ok();

    // OK
    Ok((name, args))
}

/// Parses an antecedent.
///
/// # Arguments
/// - `input`: The [`ParseStream`] to parse from.
///
/// # Returns
/// A parsed consequent, as a tuple of an identifier and an optional argument list wrapped in parenthesis.
fn parse_antecedent(input: ParseStream) -> Result<(Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Error> {
    // Parse 'not' first
    let name: Ident = input.parse()?;
    let (not, name): (Option<Ident>, Ident) = if name == "not" {
        // Parse a second ident and swap 'em
        let not: Ident = name;
        let name: Ident = input.parse()?;
        (Some(not), name)
    } else {
        // No not found
        (None, name)
    };

    // Parse the parenthesis optionally
    let args: Option<(Paren, Punctuated<Ident, Comma>)> = |input: ParseStream| -> Result<(Paren, Punctuated<Ident, Comma>), Error> {
        let content;
        let paren: Paren = parenthesized!(content in input);
        let args: Punctuated<Ident, Comma> = content.parse_terminated(Ident::parse, Token![,])?;
        Ok((paren, args))
    }(input)
    .ok();

    // OK
    Ok((not, name, args))
}





/***** HELPERS *****/
/// Defines the attributes we parse from the toplevel.
struct DatalogAttributes {
    /// The initial path to use to refer to the crate.
    crate_path: Path,
    /// The string used as `from`.
    from: LitStr,
}
impl Parse for DatalogAttributes {
    #[inline]
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // Attempt to parse an attribute thingy first
        let attrs: Vec<Attribute> = Attribute::parse_inner(input)?;

        // Create a sensible default
        let mut segments: Punctuated<PathSegment, PathSep> = Punctuated::new();
        segments.push(PathSegment { ident: Ident::new("justact_datalog", Span::call_site()), arguments: PathArguments::None });
        let mut res: Self =
            Self { crate_path: Path { leading_colon: Some(PathSep::default()), segments }, from: LitStr::new("<auto-generated>", Span::call_site()) };

        // Iterate over the attributes to deviate from the default
        for attr in attrs {
            match attr.meta {
                Meta::Path(p) => {
                    if p.is_ident("crate") {
                        // Change the path to be from within this crate
                        let mut segments: Punctuated<PathSegment, PathSep> = Punctuated::new();
                        segments.push(PathSegment { ident: Ident::new("crate", p.span()), arguments: PathArguments::None });
                        res.crate_path = Path { leading_colon: None, segments };
                    } else {
                        return Err(Error::new(p.span(), "Unknown datalog snippet attribute"));
                    }
                },
                Meta::NameValue(nv) => {
                    if nv.path.is_ident("from") {
                        // Parse the value as a string literal
                        let from: LitStr = if let Expr::Lit(ExprLit { attrs: _, lit: Lit::Str(from) }) = nv.value {
                            from
                        } else {
                            return Err(Error::new(nv.value.span(), "Expected a string literal"));
                        };

                        // Set it
                        res.from = from;
                    } else {
                        return Err(Error::new(nv.path.span(), "Unknown datalog snippet attribute"));
                    }
                },
                Meta::List(l) => return Err(Error::new(l.path.span(), "Unknown datalog snippet attribute")),
            }
        }

        // Done!
        Ok(res)
    }
}





/***** LIBRARY *****/
#[proc_macro]
pub fn datalog(input: TokenStream) -> TokenStream {
    match |input: ParseStream| -> Result<TokenStream2, syn::parse::Error> {
        // Parse from the input first: attributes
        let attrs: DatalogAttributes = input.parse()?;

        // Next, start building the tokens
        let crate_path: &Path = &attrs.crate_path;
        let from_str: &LitStr = &attrs.from;
        let mut rules: Vec<TokenStream2> = Vec::new();
        while !input.is_empty() {
            let (consequences, antecedents, _): (
                Punctuated<(Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma>,
                Option<((Colon, Minus), Punctuated<(Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma>)>,
                Dot,
            ) = {
                // Parse the consequences
                let consequences = parse_punctuated(input, parse_consequent)?;
                if consequences.is_empty() {
                    return Err(input.error("Expected at least one consequent"));
                }

                // Parse the antecedents, if any
                let antecedents = if let (Ok(colon), Ok(minus)) = (input.parse::<Colon>(), input.parse::<Minus>()) {
                    // Parse a punctuated list of antecedents
                    let antecedents: Punctuated<(Option<Ident>, Ident, Option<(Paren, Punctuated<Ident, Comma>)>), Comma> =
                        parse_punctuated(input, parse_antecedent)?;
                    if antecedents.is_empty() {
                        return Err(input.error("Expected at least one antecedent"));
                    }
                    Some(((colon, minus), antecedents))
                } else {
                    None
                };

                // Parse the final dot
                let dot: Dot = input.parse()?;

                // Done parsing!
                (consequences, antecedents, dot)
            };

            // Now we re-serialize. First, generate consequences
            let consequences_tokens: Vec<TokenStream2> = consequences.into_iter().map(|(name, args)| {
                // Generate the arguments
                let (paren_span, args_tokens): (Option<Span>, TokenStream2) = if let Some((paren, args)) = args {
                    // Collect the arguments
                    let args: Vec<TokenStream2> = args.into_iter().map(|arg| {
                        let sarg: String = arg.to_string();

                        // Note it down as a variable if it starts with an uppercase
                        if sarg.chars().next().expect("Got empty consequence argument identifier").is_uppercase() {
                            quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Var(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                        } else {
                            quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Atom(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                        }
                    }).collect();

                    // Put them in a punctuated list
                    let mut args_tokens: TokenStream2 = TokenStream2::new();
                    for (i, arg) in args.into_iter().enumerate() {
                        if i > 0 {
                            args_tokens.extend(quote_spanned! { arg.span() => , p => #crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, });
                        }
                        args_tokens.extend(quote_spanned!{ arg.span() => v => #arg });
                    }

                    // Serialize it to one set of arguments
                    (Some(paren.span.join()), quote_spanned!{ paren.span.join() => Some(#crate_path::ast::AtomArgs {
                        paren_tokens: #crate_path::ast::Parens { open: #crate_path::ast::Span::new(#from_str, "("), close: #crate_path::ast::Span::new(#from_str, ")") },
                        args: #crate_path::ast::punct![ #args_tokens ],
                    })})
                } else {
                    (None, quote_spanned!{ name.span() => None })
                };

                // Generate the consequent atom
                let sname: String = name.to_string();
                quote_spanned! {
                    if let Some(paren) = paren_span { name.span().join(paren).unwrap_or_else(|| name.span()) } else { name.span() } =>
                    #crate_path::ast::Atom {
                        ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                        args: #args_tokens,
                    }
                }
            }).collect();
            // let consequences_tokens: TokenStream2 = quote_spanned! { consequences_tokens.first().expect("Got empty consequence list").span().join(consequences_tokens.last().expect("Got empty consequence list").span()).expect("Got consequences from different files") => ::std::vec![ #(#consequences_tokens),* ] };
            let first_span: Span = consequences_tokens.first().expect("Got empty consequence list").span();
            let mut consequences_tokens_punct: TokenStream2 = TokenStream2::new();
            for (i, cons) in consequences_tokens.into_iter().enumerate() {
                if i > 0 {
                    consequences_tokens_punct.extend(quote_spanned! { cons.span() => , p => #crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, });
                }
                consequences_tokens_punct.extend(quote_spanned!{ cons.span() => v => #cons });
            }
            let consequences_tokens: TokenStream2 = quote_spanned! { first_span => #crate_path::ast::punct![ #consequences_tokens_punct ] };

            // Next, generate the antecedents
            let antecedents_tokens: TokenStream2 = if let Some(((colon, _), antecedents)) = antecedents {
                // Generate all the antecedents
                let antecedents: Vec<TokenStream2> = antecedents.into_iter().map(|(not, name, args)| {
                    // Generate the arguments
                    let (paren_span, args_tokens): (Option<Span>, TokenStream2) = if let Some((paren, args)) = args {
                        // Generate the individual arguments
                        let args: Vec<TokenStream2> = args.into_iter().map(|arg| {
                            let sarg: String = arg.to_string();

                            // Note it down as a variable if it starts with an uppercase
                            if sarg.chars().next().expect("Got empty antecedent argument identifier").is_uppercase() {
                                quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Var(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                            } else {
                                quote_spanned! { arg.span() => #crate_path::ast::AtomArg::Atom(#crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sarg) }) }
                            }
                        }).collect();

                        // Put them in a punctuated list
                        let mut args_tokens: TokenStream2 = TokenStream2::new();
                        for (i, arg) in args.into_iter().enumerate() {
                            if i > 0 {
                                args_tokens.extend(quote_spanned! { arg.span() => , p => #crate_path::ast::Comma{ span: #crate_path::ast::Span::new(#from_str, ",") }, });
                            }
                            args_tokens.extend(quote_spanned!{ arg.span() => v => #arg });
                        }

                        // Serialize them to a single argument list
                        (Some(paren.span.join()), quote_spanned!{ paren.span.join() => Some(#crate_path::ast::AtomArgs {
                            paren_tokens: #crate_path::ast::Parens { open: #crate_path::ast::Span::new(#from_str, "("), close: #crate_path::ast::Span::new(#from_str, ")") },
                            args: #crate_path::ast::punct![ #args_tokens ],
                        })})
                    } else {
                        (None, quote_spanned!{ name.span() => None })
                    };

                    // Generate the consequent atom
                    let sname: String = name.to_string();
                    let span: Span = if let Some(paren) = paren_span { name.span().join(paren).unwrap_or_else(|| name.span()) } else { name.span() };
                    if not.is_some() {
                        quote_spanned! {
                            span =>
                            #crate_path::ast::Literal::NegAtom(#crate_path::ast::NegAtom {
                                not_token: #crate_path::ast::Not { span: #crate_path::ast::Span::new(#from_str, "not") },
                                atom: #crate_path::ast::Atom {
                                    ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                                    args: #args_tokens,
                                },
                            })
                        }
                    } else {
                        quote_spanned! {
                            span =>
                            #crate_path::ast::Literal::Atom(#crate_path::ast::Atom {
                                ident: #crate_path::ast::Ident { value: #crate_path::ast::Span::new(#from_str, #sname) },
                                args: #args_tokens,
                            })
                        }
                    }
                }).collect();

                // Serialize them to a single buffer
                let mut antecedents_tokens: TokenStream2 = TokenStream2::new();
                for (i, ant) in antecedents.into_iter().enumerate() {
                    // Push the punctuation first
                    if i > 0 {
                        antecedents_tokens.extend(quote_spanned! { ant.span() => , p => #crate_path::ast::Comma { span: #crate_path::ast::Span::new(#from_str, ",") } , });
                    }
                    antecedents_tokens.extend(quote_spanned!{ ant.span() => v => #ant });
                }

                // Serialize them to a single RuleAntecedents
                // quote_spanned! {
                //     colon.span.join(last_span).expect("Colon and last antecedent are from different files") =>
                //     Some(#crate_path::ast::RuleAntecedents {
                //         arrow_token: #crate_path::ast::Arrow { span: #crate_path::ast::Span::new(#from_str, ":-") },
                //         antecedents: #crate_path::ast::punct![ #antecedents_tokens ],
                //     })
                // }
                quote_spanned! {
                    colon.span =>
                    Some(#crate_path::ast::RuleAntecedents {
                        arrow_token: #crate_path::ast::Arrow { span: #crate_path::ast::Span::new(#from_str, ":-") },
                        antecedents: #crate_path::ast::punct![ #antecedents_tokens ],
                    })
                }
            } else {
                quote_spanned!{ consequences_tokens.span() => None }
            };

            // Alright; now we can build the parsed versions
            // rules.push(quote_spanned! {
            //     consequences_tokens.span().join(antecedents_tokens.span()).expect("Consequences and antecedents are from different files") =>
            //     #crate_path::ast::Rule {
            //         consequences: #consequences_tokens,
            //         tail: #antecedents_tokens,
            //         dot: #crate_path::ast::Dot { span: #crate_path::ast::Span::new(#from_str, ".") },
            //     }
            // });
            rules.push(quote_spanned! {
                consequences_tokens.span() =>
                #crate_path::ast::Rule {
                    consequences: #consequences_tokens,
                    tail: #antecedents_tokens,
                    dot: #crate_path::ast::Dot { span: #crate_path::ast::Span::new(#from_str, ".") },
                }
            });
        }

        // Write the remainder
        // let span: Span = if let (Some(first), Some(last)) = (rules.first(), rules.last()) {
        //     first.span().join(last.span()).expect("First and last rules are from different files")
        // } else {
        //     Span::call_site()
        // };
        let span: Span = if let Some(first) = rules.first() {
            first.span()
        } else {
            Span::call_site()
        };
        Ok(quote_spanned! {
            span =>
            #crate_path::ast::Spec {
                rules: ::std::vec![
                    #(#rules),*
                ]
            }
        })
    }
    .parse2(input.into())
    {
        Ok(tokens) => tokens.into(),
        Err(err) => err.into_compile_error().into(),
    }
}
